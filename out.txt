# app.py
```
from flask import Flask, jsonify
import csv
import os
from data_retrieval import fetch_games, Team, Game
from picks import Picks  
import math
import numpy as np
import random

app = Flask(__name__)

from flask import Flask, jsonify, render_template
import os

# Function to read picks from CSV files
def read_picks_from_csv(file_path):
    with open(file_path, mode='r', encoding='utf-8') as csvfile:
        reader = csv.DictReader(csvfile)
        picks_data = list(reader)
    return picks_data

# Function to load all picks
def load_all_picks(games):
    picks_folder = 'picks2'
    all_picks = {}
    for file_name in os.listdir(picks_folder):
        if file_name.endswith('_picks.csv'):
            name = file_name.replace('_picks.csv', '').replace('_', ' ').title()
            file_path = os.path.join(picks_folder, file_name)
            picks_data = read_picks_from_csv(file_path)
            all_picks[name] = Picks(name, picks_data, games)
    return all_picks

def game_to_json(game):
    return {
        'bowl_name': game.bowl_name,
        'status': game.status,
        'display_clock': game.display_clock,
        'period': game.period,
        'home_team': {
            'location': game.home_team.location,
            'name': game.home_team.name,
            'abbreviation': game.home_team.abbreviation,
            'display_name': game.home_team.display_name,
            'short_display_name': game.home_team.short_display_name,
            'score': game.home_team.score,
        },
        'away_team': {
            'location': game.away_team.location,
            'name': game.away_team.name,
            'abbreviation': game.away_team.abbreviation,
            'display_name': game.away_team.display_name,
            'short_display_name': game.away_team.short_display_name,
            'score': game.away_team.score,
        },
        'down_distance_text': game.down_distance_text,
        'possession_text': game.possession_text,
        'winner': game.winner.abbreviation if game.winner else None,
    }

def calculate_winner_percentage(game):
    if game.spread is None:
        return None  # If there's no spread, we can't calculate a percentage
    spread = float(game.spread)
    sigma = 10  # Adjust this value based on the sportsbook's assessment
    spread = -spread
    if game.projected_winner is None: return None
    percentage = 1 / (1 + math.exp(-spread / sigma))
    ret = (1 - percentage) * 100
    if game.projected_winner == game.home_team:
        ret = percentage * 100
    #print(f"Game: {game.bowl_name},Spread: {spread}, {game.projected_winner.abbreviation} Percentage: {ret}")
    return ret
    

def count_picks_for_team(team, games):
    # Load all picks from the CSV files (assuming this is how you store picks)
    all_picks = load_all_picks(games)
    count = 0
    for picks in all_picks.values():
        for pick in picks.picks:
            if pick.team and pick.team.abbreviation == team.abbreviation:
                count += 1
    return count

# Function to perform simulations and calculate win probabilities
def simulate_win_probabilities(all_picks, games_dict, num_simulations=2000):
    win_counts = {name: 0 for name in all_picks.keys()}
    
    for _ in range(num_simulations):
        simulated_standings = {name: picks.calculate_correct_picks()  for name, picks in all_picks.items()}
        
        for game in games_dict.values():
            if game.winner is None:  # If the game hasn't been decided yet
                win_percentage = calculate_winner_percentage(game)
                if win_percentage is not None:
                    # Simulate the game outcome based on the win percentage
                    if random.random() < (win_percentage / 100):
                        winner = game.projected_winner
                    else:
                        winner = game.home_team if game.home_team != game.projected_winner else game.away_team
                    
                    # Update standings based on the simulated outcome
                    for name, picks in all_picks.items():
                        for pick in picks.picks:
                            if pick.game == game and pick.team == winner:
                                simulated_standings[name] += 1
        
        # Determine the winner for this simulation
        simulated_winner = max(simulated_standings, key=simulated_standings.get)
        win_counts[simulated_winner] += 1
    
    # Calculate win probabilities based on the simulation results
    win_probabilities = {name: count / num_simulations for name, count in win_counts.items()}
    return win_probabilities

@app.route('/all_games', methods=['GET'])
def get_all_games():
    games = fetch_games()
    in_progress_games = [game_to_json(game) for game in games if True]
    return jsonify(in_progress_games)

@app.route('/games', methods=['GET'])
def get_games():
    games = fetch_games()
    in_progress_games = [game_to_json(game) for game in games if game.status == 'In Progress' or game.status == 'Halftime' or game.status == 'End of Period']
    return jsonify(in_progress_games)

# Endpoint to get the leaderboard
@app.route('/leaderboard', methods=['GET'])
def get_leaderboard():
    games = fetch_games()
    games_dict = {game.bowl_name: game for game in games}
    all_picks = load_all_picks(games)
    
    # Analyze picks
    for picks in all_picks.values():
        picks.analyze_picks(games_dict)

    # Calculate scores and sort leaderboard
    # Perform simulations to calculate win probabilities
    win_probabilities = simulate_win_probabilities(all_picks, games_dict)
    leaderboard = []
    projected_totals = []  # List to store projected_totals
    for name, picks in all_picks.items():
        correct_picks = sum(1 for pick in picks.picks if pick.correct)
        projected_points = 0
        for pick in picks.picks:
            if pick.correct is None and pick.team is not None:  # Game has not been played yet
                game = pick.game
                win_percentage = calculate_winner_percentage(game)
                if win_percentage is not None:
                    if pick.team == game.projected_winner:
                        projected_points += win_percentage / 100
                    elif pick.team is not None:
                        projected_points += (1 - (win_percentage / 100))
                    else:
                        projected_points += 0
        total_projected = correct_picks + projected_points
        projected_totals.append(total_projected)  # Add projected_total to the list
        streak = picks.calculate_streak()  # Calculate the streak
        leaderboard.append({
            'name': name,
            'correct_picks': correct_picks,
            'streak': streak,
            'projected_total': total_projected
        })
    leaderboard.sort(key=lambda x: x['correct_picks'], reverse=True)

    mean = np.mean(projected_totals)  # Calculate the mean
    stdev = np.std(projected_totals)  # Calculate the standard deviation

    print(f"Mean: {mean}, Standard Deviation: {stdev}")  # Debug print
    
    def convert_to_odds(probability):
        probability = probability / 100
        if probability == 0:
            return "N/A"
        if probability >= 0.5:
            # Favorite (probability >= 50%)
            odds = -100 * (probability / (1 - probability))
        else:
            # Underdog (probability < 50%)
            odds = 100 * ((1 - probability) / probability)

        return round(odds)

    # Update leaderboard with win probabilities
    for entry in leaderboard:
        entry['win_probability'] = win_probabilities[entry['name']] * 100  # Convert to percentage
        entry['odds_to_win'] = convert_to_odds(entry['win_probability'])
        print(f"{entry['name']}: {entry['projected_total']}, {entry['win_probability']}, {entry['odds_to_win']}")

    return jsonify(leaderboard)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/picks/<name>', methods=['GET'])
def get_picks(name):
    print(f"Fetching picks for: {name}")  # Debug print
    file_name = f"{name.replace(' ', '_')}_picks.csv"
    file_path = os.path.join('picks2', file_name)
    print(f"Looking for file: {file_path}")  # Debug print

    if not os.path.exists(file_path):
        print(f"File not found: {file_path}")  # Debug print
        return jsonify({'error': 'Picks not found'}), 404

    picks_data = read_picks_from_csv(file_path)
    games = fetch_games()
    games_dict = {game.bowl_name: game for game in games}

    # Create a Picks object and analyze the picks
    picks = Picks(name, picks_data, games)
    picks.analyze_picks(games_dict)

    # Serialize the picks to JSON
    picks_json = []
    for pick in picks.picks:
        if pick.team is None:
            team_data = {
                'display_name': 'No Pick',
                'short_display_name': 'No Pick',
                'location': 'No Pick',
                'abbreviation': 'No Pick',
            }
        else:
            team_data = {
                'display_name': pick.team.display_name,
                'short_display_name': pick.team.short_display_name,
                'location': pick.team.location,
                'abbreviation': pick.team.abbreviation,
            }
        pick_data = {
            'game': game_to_json(pick.game),
            'team': team_data,
            'correct': pick.correct
        }
        picks_json.append(pick_data)

    return jsonify(picks_json)

@app.route('/upcoming_games', methods=['GET'])
def get_upcoming_games():
    games = fetch_games()
    upcoming_games = [game for game in games if game.status == 'Scheduled'][:9]  # Select the next 7 games
    # You'll need to add logic to calculate the number of picks for each team
    # and the projected winner percentage based on the odds.
    # This is just a placeholder for the structure.


    upcoming_games_info = [
        {
            'bowl_name': game.bowl_name,
            'date': game.date.strftime('%Y-%m-%d %H:%M'),  # Format date as needed
            'home_team': game.home_team.location,
            'away_team': game.away_team.location,
            'projected_winner': game.projected_winner.location if game.projected_winner else None,
            'projected_winner_line': game.spread,  # Implement this function
            'home_team_picks': count_picks_for_team(game.home_team, games),  # Implement this function
            'away_team_picks': count_picks_for_team(game.away_team, games),  # Implement this function
        }
        for game in upcoming_games
    ]
    return jsonify(upcoming_games_info)

if __name__ == '__main__':
    app.run(debug=True)
```

# clean_data.py
```
import os
import pandas as pd

# Load the provided Excel file
file_path = 'picks/2023 Bowl Picks Start 3.xlsx'
df = pd.read_excel(file_path)

# Display the first few rows of the dataframe to understand its structure
df.head()


# Create a directory for the picks
picks_dir = 'picks2'
os.makedirs(picks_dir, exist_ok=True)

# Extract the first row as header
header = df.iloc[0]
# Update the dataframe to exclude the first row and set the correct header
df.columns = header
df = df[1:]

# List of files created
created_files = []

# Iterate over each column (excluding the first one which is the Bowl name)
for column in df.columns[1:]:
    # Skip empty columns
    if column is None or pd.isna(column) or column == 'Matchup' or column == 'Date' or column == "Time (ET)":
        continue
    
    # Split the name into first and last name and create the file name
    file_name = f"{column.replace(' ','_').strip()}_picks.csv"

    # Create a dataframe for each person's picks
    picks_df = pd.DataFrame({
        'game': df['Bowl'],
        'team': df[column]
    })

    # Save the dataframe as a CSV file
    full_file_path = os.path.join(picks_dir, file_name)
    picks_df.to_csv(full_file_path, index=False)
    created_files.append(full_file_path)




```

# data_retrieval.py
```
import requests
import re
import datetime

# Define the Team class
class Team:
    def __init__(self, info):
        self.location = info.get('location', 'Unknown Location')
        self.name = info.get('name', 'Unknown Name')
        self.abbreviation = info.get('abbreviation', 'Unknown Abbreviation')
        self.display_name = info.get('displayName', 'Unknown Display Name')
        self.short_display_name = info.get('shortDisplayName', 'Unknown Short Display Name')
        self.score = info.get('score', '0')  # Score is added here for convenience

# Define the Game class
class Game:
    def __init__(self, event):
        self.bowl_name = event.get('competitions', [{}])[0].get('notes', [{}])[0].get('headline', 'Unknown Bowl')
        self.status = event.get('status', {}).get('type', {}).get('description', 'Status Unknown')
        self.display_clock = event.get('status', {}).get('displayClock', '00:00')
        self.period = event.get('status', {}).get('period', 0)
        self.down_distance_text = ''
        self.possession_text = ''
        self.competitors = event.get('competitions', [{}])[0].get('competitors', [])
        self.home_team = None
        self.away_team = None
        self.projected_winner = None
        self.spread: str = None
        self.over_under = None
        self.winner = None
        self.date_string = event.get('date', 'Unknown Date')
        self.date = datetime.datetime.strptime(self.date_string, "%Y-%m-%dT%H:%MZ")
        self.picks = 0

        # Create Team objects for home and away teams
        for team_info in self.competitors:
            team = Team(team_info.get('team', {}))
            team.score = team_info.get('score', '0')  # Add the score to the team object
            if team_info.get('homeAway') == 'home':
                self.home_team = team
            elif team_info.get('homeAway') == 'away':
                self.away_team = team

        # Extract odds information
        odds_info = event.get('competitions', [{}])[0].get('odds', [{}])
        if odds_info:
            odds_info = odds_info[0]  # Assuming the first odds info is what we want
            self.spread = odds_info.get('spread')
            self.over_under = odds_info.get('overUnder')

            # Extract the projected winner from the details field
            details = odds_info.get('details', '')
            match = re.search(r'([A-Z]+) -?\d+(\.\d+)?', details)
            if match:
                winner_abbreviation = match.group(1)
                # Determine the projected winner based on the abbreviation
                if self.home_team.abbreviation == winner_abbreviation:
                    self.projected_winner = self.home_team
                elif self.away_team.abbreviation == winner_abbreviation:
                    self.projected_winner = self.away_team
                    #self.spread = -self.spread  # Flip the spread if the away team is the projected winner

        # Extract situation information if the game is not final
        if self.status != 'Final':
            situation = event.get('competitions', [{}])[0].get('situation', {})
            self.down_distance_text = situation.get('downDistanceText', '')
            self.possession_text = situation.get('possessionText', '')
        else:
            self.winner = self.home_team if int(self.home_team.score) > int(self.away_team.score) else self.away_team

    def set_picks(self, picks):
        self.picks = picks

    def __str__(self):
        return f"**{self.status}** {self.bowl_name}: {self.home_team.location}({self.home_team.abbreviation}) {self.home_team.score} vs. {self.away_team.location}({self.away_team.abbreviation}) {self.away_team.score}"

# Function to fetch events and create Game objects
def fetch_games():
    url = 'https://site.api.espn.com/apis/site/v2/sports/football/college-football/scoreboard'
    response = requests.get(url)
    data = response.json()
    events = data.get('events', [])
    games = []
    for event in events:
        game = Game(event)
        games.append(game)
    
    # Sort the games by date
    games.sort(key=lambda x: x.date)
    
    return games
```

# Dockerfile
```
 # Use the official lightweight Python image.
# https://hub.docker.com/_/python
FROM python:3.9-slim

# Allow statements and log messages to immediately appear in the Knative logs
ENV PYTHONUNBUFFERED True

# Copy local code to the container image.
ENV APP_HOME /app
WORKDIR $APP_HOME
COPY . ./

# Install production dependencies.
RUN pip install Flask gunicorn pandas requests numpy

# Run the web service on container startup. Here we use the gunicorn
# webserver, with one worker process and 8 threads.
# For environments with multiple CPU cores, increase the number of workers
# to be equal to the cores available.
CMD exec gunicorn --bind :$PORT --workers 1 --threads 8 --timeout 0 app:app
```

# picks.py
```
class Picks:
    def __init__(self, name, data, games):
        self.name = name
        self.picks: list[Pick] = []
        self.parse_picks(data, games)

    def calculate_correct_picks(self):
        # Calculate the number of correct picks
        return sum(1 for pick in self.picks if pick.correct)

    def parse_picks(self, data, games):
        def find_game_by_name(games, name):
            for game in games:
                if game.bowl_name == name:
                    return game
            return None
        
        def find_team_by_abbreviation(game, abbreviation):
            if abbreviation == game.home_team.abbreviation:
                return game.home_team
            elif abbreviation == game.away_team.abbreviation:
                return game.away_team
            else:
                return None
    
        for pick in data:
            game = find_game_by_name(games, pick['game'])
            if game is None:
                #print(f"Unable to find game: {pick['game']}")
                continue
            team = None
            if game.bowl_name == 'CFP National Championship Pres. by AT&T':
                team = find_team_by_abbreviation(self.picks[-2].game, pick['team'])
                if team is None:
                    team = find_team_by_abbreviation(self.picks[-1].game, pick['team'])
            else:
                team = find_team_by_abbreviation(game, pick['team'])
            self.picks.append(Pick(game, team))
    
    
    def analyze_picks(self, games):
        for pick in self.picks:
            if pick.team is None: 
                continue
            if pick.game and pick.game.winner:
                pick.correct = pick.game.winner.abbreviation == pick.team.abbreviation

    def calculate_streak(self):
        streak_type = None
        streak_count = 0
        for pick in reversed(self.picks):
            if pick.correct is None:  # Skip games without a result
                continue
            if streak_type is None:
                streak_type = 'W' if pick.correct else 'L'
                streak_count = 1
            elif ((pick.correct and streak_type == 'W') or
                  (not pick.correct and streak_type == 'L')):
                streak_count += 1
            else:
                break  # Streak ended
        return f"{streak_type}{streak_count}" if streak_count > 0 else ""

class Pick:
    def __init__(self, game, team):
        self.game = game
        self.team = team
        self.correct: bool = None
```

# README.md
```
# football-pool-tracker
```

# templates\index.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Football Bowl Pool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .container {
            width: 90%;
            margin: auto;
            display: grid;
            grid-template-rows: auto auto 1fr;
            gap: 20px;
        }
        .content-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .leaderboard, .upcoming-games {
            width: 100%; /* Adjust the width as needed */
        }
        .upcoming-game-card {
            display: grid;
            grid-template-columns: 1fr 3fr 1fr;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            margin-bottom: 10px;
            background-color: #f9f9f9;
        }
        .upcoming-games {
            margin-top: 20px;
        }
        .leaderboard {
            margin-top: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .correct {
        background-color: #dff0d8; /* Light green to highlight correct picks */
        }
        .incorrect {
            background-color: #f2dede; /* Light red to highlight incorrect picks */
        }
        /* Reset styles for rows within the modal */
        #picksModalBody tr {
            background-color: #fff; /* Set a default background color for all rows */
        }
        #picksModalBody tr.correct {
            background-color: #dff0d8; /* Light green for correct picks */
        }
        #picksModalBody tr.incorrect {
            background-color: #f2dede; /* Light red for incorrect picks */
        }
        .green {
                color: green;
        }
        .red {
                color: red;
        }
        .game-card {
            display: grid;
            grid-template-columns: 1fr 3fr 1fr;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            margin-bottom: 10px;
            background-color: #f9f9f9;
        }
        .team-info {
            text-align: center;
            font-size: 1em;
        }
        .team-score {
            font-size: 1.5em;
            font-weight: bold;
        }
        .game-status {
            text-align: center;
            font-weight: bold;
        }
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgb(0,0,0); /* Fallback color */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto; /* 15% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%; /* Could be more or less, depending on screen size */
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .highlight {
            background-color: #dff0d8; /* Light green to highlight wins */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="text-align: center;">2023 Annual Great Grammy/John Borszcz Football Pool</h1>
        <h2 style="text-align: center;">Active Games</h2>
        <div id="games">
            <!-- Games will be loaded here -->
        </div>
    
        <div class="content-row">
            <div class="leaderboard">
                <h2 style="text-align: center;">Leaderboard</h2>
                <table id="leaderboard-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Correct Picks</th>
                            <th>Streak</th>
                            <th>1st Place Probability</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Leaderboard will be loaded here -->
                    </tbody>
                </table>
            </div>
            <div class="upcoming-games">
                <h2 style="text-align: center;">Upcoming Games</h2>
                <div id="upcoming-games-list">
                    <!-- Upcoming games will be loaded here -->
                </div>
            </div>
        </div>
    </div>
    <div id="picksModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 id="picksModalTitle">Picks for User</h2>
            <table>
                <thead>
                    <tr>
                        <th>Game</th>
                        <th>Matchup</th>
                        <th>Pick</th>
                    </tr>
                </thead>
                <tbody id="picksModalBody">
                    <!-- User's picks will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>
    

    <script>
        // Fetch and display in-progress games
        function loadGames() {
            fetch('/games')
                .then(response => response.json())
                .then(games => {
                    const gamesContainer = document.getElementById('games');
                    gamesContainer.innerHTML = games.map(game => `
                        <div class="game-card">
                            <div class="team-info">
                                <div>${game.away_team.display_name}</div>
                                <div class="team-score">${game.away_team.score}</div>
                            </div>
                            <div class="game-status">
                                <div>${game.bowl_name}</div>
                                <div>${game.display_clock} ${game.period ? 'Q' + game.period : ''}</div>
                                <div>${game.down_distance_text}</div>
                            </div>
                            <div class="team-info">
                                <div>${game.home_team.display_name}</div>
                                <div class="team-score">${game.home_team.score}</div>
                            </div>
                        </div>
                    `).join('');
                })
                .catch(error => console.error('Error fetching games:', error));
        }

        // Fetch and display leaderboard
        function loadLeaderboard() {
            fetch('/leaderboard')
                .then(response => response.json())
                .then(leaderboard => {
                    const leaderboardTable = document.getElementById('leaderboard-table').getElementsByTagName('tbody')[0];
                    leaderboardTable.innerHTML = leaderboard.map(entry => {
                        // Determine the class to apply based on the streak value
                        let streakClass = '';
                        if (entry.streak.includes('W')) {
                            streakClass = 'green';
                        } else if (entry.streak.includes('L')) {
                            streakClass = 'red';
                        }
                        return `
                            <tr>
                                <td><a href="#" onclick="loadPicks('${entry.name}')">${entry.name}</a></td>
                                <td>${entry.correct_picks}</td>
                                <td class="${streakClass}">${entry.streak}</td> 
                                <td>${entry.win_probability.toFixed(2)}%</td> 
                                
                            </tr>
                        `;
                        //<td>${entry.projected_total.toFixed(2)}</td>
                    }).join('');
                })
                .catch(error => console.error('Error fetching leaderboard:', error));
        }

        // Function to load and display a user's picks
        function loadPicks(name) {
            fetch(`/picks/${encodeURIComponent(name)}`)
                .then(response => response.json())
                .then(picks => {
                    const picksModalBody = document.getElementById('picksModalBody');
                    picksModalBody.innerHTML = picks.map(pick => {
                        // Determine the class to apply based on the pick outcome
                        let rowClass = '';
                        if (pick.correct === true) {
                            rowClass = 'correct';
                        } else if (pick.correct === false) {
                            rowClass = 'incorrect';
                        }
                        // Generate the table row with the appropriate class
                        return `
                            <tr class="${rowClass}">
                                <td>${pick.game.bowl_name}</td>
                                <td>${pick.game.home_team.location} vs ${pick.game.away_team.location}</td>
                                <td>${pick.team.location}</td>
                            </tr>
                        `;
                    }).join('');
                    document.getElementById('picksModalTitle').innerText = `Picks for ${name}`;
                    showModal();
                })
                .catch(error => console.error('Error fetching picks:', error));
        }

        // Show the modal
        function showModal() {
            const modal = document.getElementById('picksModal');
            modal.style.display = 'block';
        }

        // Hide the modal
        function hideModal() {
            const modal = document.getElementById('picksModal');
            modal.style.display = 'none';
        }

        // Get the <span> element that closes the modal
        const span = document.getElementsByClassName('close')[0];

        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
            hideModal();
        }

        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
            const modal = document.getElementById('picksModal');
            if (event.target == modal) {
                hideModal();
            }
        }
        // Fetch and display upcoming games
        function loadUpcomingGames() {
            fetch('/upcoming_games')
                .then(response => response.json())
                .then(upcomingGames => {
                    const upcomingGamesList = document.getElementById('upcoming-games-list');
                    upcomingGamesList.innerHTML = upcomingGames.map(game => `
                        <div class="upcoming-game-card">
                            <div class="team-info">
                                <b><div>${game.away_team}</div></b>
                                <div>Picks: ${game.away_team_picks}</div>
                                <div>${game.projected_winner === game.away_team ? `(-${game.projected_winner_line})` : ''}</div>
                            </div>
                            <div class="game-status">
                                <div>${game.bowl_name}</div>
                                <div>${new Date(new Date(game.date).getTime() - (5 * 60 * 60 * 1000)).toLocaleString('en-US', { timeZone: 'America/New_York' })} EST</div>
                            </div>
                            <div class="team-info">
                                <b><div>${game.home_team}</div></b>
                                <div>Picks: ${game.home_team_picks}</div>
                                <div>${game.projected_winner === game.home_team ? `(${game.projected_winner_line})` : ''}</div>
                            </div>
                        </div>
                    `).join('');
                })
                .catch(error => console.error('Error fetching upcoming games:', error));
        }

        // Call loadUpcomingGames in the DOMContentLoaded event listener
        document.addEventListener('DOMContentLoaded', function() {
            loadGames();
            loadLeaderboard();
            loadUpcomingGames(); // Add this line
        });
    </script>
</body>
</html>
```

